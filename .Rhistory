lacp <- min(0, lacp)
# Note: The proposal is symmetrical and therefore does not appear in the value of acceptance / rejection!
lgu <- log(runif(1))  # lgu is negative
## if u < acp accept the move
if(lgu < lacp)
{
th0 <- delta
nacp = nacp + 1
}
if(i>burnin & (i-burnin)%%thin==0)
{
th[(i-burnin)/thin,] = th0
}
if(i%%1000==0) cat("*** Iteration number ", i,"/", niter,"th=",tail(th,1) ,"\n")
}
cat("Acceptance rate =", nacp/niter, "\n")
return(th)
}
th.post <- metro_hastings(niter = niter, burnin = burnin, thin = thin, th0 = th0, Sig = Sig, y0 = starting_point)
k2
k3
th0 = c(0.5,-0.7)
th.post <- metro_hastings(niter = niter, burnin = burnin, thin = thin, th0 = th0, Sig = Sig, y0 = starting_point)
th <- matrix(nrow= ceiling((niter-burnin)/thin), ncol = 2)
nacp = 0 # number of accepted moves
for(i in 1:(niter))
{
## propose delta: the mean is given by the previous value
delta <- as.vector(rmvnorm(1, mean = th0, sig = Sig))
# First consider the log of accept/reject ratio
# numerator
lacp <- posterior(th = delta, y_obs = y_obs, y0 = y0)
# denominator
lacp <- lacp - posterior(th = th0, y_obs = y_obs, y0 = y0)
lacp <- min(0, lacp)
# Note: The proposal is symmetrical and therefore does not appear in the value of acceptance / rejection!
lgu <- log(runif(1))  # lgu is negative
## if u < acp accept the move
if(lgu < lacp)
{
th0 <- delta
nacp = nacp + 1
}
if(i>burnin & (i-burnin)%%thin==0)
{
th[(i-burnin)/thin,] = th0
}
if(i%%1000==0) cat("*** Iteration number ", i,"/", niter,"th=",tail(th,1) ,"\n")
}
metro_hastings <- function(niter, burnin, thin, th0, Sig,y0)
{
# define the vector that contains the output MCMC sample
th <- matrix(nrow= ceiling((niter-burnin)/thin), ncol = 2)
nacp = 0 # number of accepted moves
# Start from th0
for(i in 1:(niter))
{
## propose delta: the mean is given by the previous value
delta <- as.vector(rmvnorm(1, mean = th0, sig = Sig))
# First consider the log of accept/reject ratio
# numerator
lacp <- posterior(th = delta, y_obs = y_obs, y0 = y0)
# denominator
lacp <- lacp - posterior(th = th0, y_obs = y_obs, y0 = y0)
lacp <- min(0, lacp)
# Note: The proposal is symmetrical and therefore does not appear in the value of acceptance / rejection!
lgu <- log(runif(1))  # lgu is negative
## if u < acp accept the move
if(lgu < lacp)
{
th0 <- delta
nacp = nacp + 1
}
if(isTRUE(all.equal(th0,c(NA,NA)))) cat("NA here! num iter = ", niter,"\n")
if(i>burnin & (i-burnin)%%thin==0)
{
th[(i-burnin)/thin,] = th0
}
if(i%%1000==0) cat("*** Iteration number ", i,"/", niter,"th=",tail(th,1) ,"\n")
}
cat("Acceptance rate =", nacp/niter, "\n")
return(th)
}
th0 = c(0.5,-0.7)
th.post <- metro_hastings(niter = niter, burnin = burnin, thin = thin, th0 = th0, Sig = Sig, y0 = starting_point)
t0 = -2
t_end = 2
N = 20
t_obs = seq(t0,t_end,length=N)
#Set the true parameters
k1 = 0.219
k2 = 0.5287
k3 = -0.805
k4 = 0
y_true = k1*t_obs^3 + k2*t_obs^2 + k3*t_obs + k4
y_obs= k1*t_obs^3 + k2*t_obs^2 + k3*t_obs +k4 + rnorm(N,0,0.5)
windows()
plot(t_obs,y_obs)
lines(t_obs,y_true,col="red")
## We assume k1,k4,sigma(=0.5) known and assign a normal prior with parameters 0, 5 to k2,k3
posterior <- function (th,y_obs,y0){
n = length(y_obs)
times = seq(-2,2, length = n)
y_mod = 0.219*times^3 + th[1]*times^2 + th[2]*times + 0
out = 0
#define the likelihood
for(i in 1:n)
{
out <- out + dnorm(y_obs[i],mean = y_mod[i], sd = 0.5,log=T)
}
#Multiply times the prior
out = out + dnorm(th[1], mean = 0, sd = 5, log = T) + dnorm(th[2], mean = 0, sd = 5, log = T)
return(out)
}
grid.k2 = seq(-2,2,length=50)
grid.k3 = seq(-2,2,length=50)
post_grid = matrix(nrow=50,ncol=50)
for(k in 1:50){
for(j in 1:50){
post_grid[k,j] = posterior(c(grid.k2[k],grid.k3[j]),y_obs,starting_point)
}
if(k%%10 == 0)
cat("k=",k, "\n")
}
x11()
# Contour fun: Create a contour plot, or add contour lines to an existing plot
contour(grid.k2, grid.k3, post_grid, lwd = 3, labcex = 1.1, col = "blue", main = "Posterior density",
xlab = "k2", ylab = "k3")
x11()
persp(grid.k2, grid.k3, post_grid, theta = 30)
# Define the proposal as gaussian with suitable variance
ottimo <- optim(par = c(mean(y_obs), log(sd(y_obs))),
fn = posterior, y_obs = y_obs,
y0 = y0,
hessian = T, control = list(fnscale=-1))
Sig <- - solve(ottimo$hessian)
Sig
gamma = 100
Sig = gamma * Sig
metro_hastings <- function(niter, burnin, thin, th0, Sig,y0)
{
# define the vector that contains the output MCMC sample
th <- matrix(nrow= ceiling((niter-burnin)/thin), ncol = 2)
nacp = 0 # number of accepted moves
# Start from th0
for(i in 1:(niter))
{
## propose delta: the mean is given by the previous value
delta <- as.vector(rmvnorm(1, mean = th0, sig = Sig))
# First consider the log of accept/reject ratio
# numerator
lacp <- posterior(th = delta, y_obs = y_obs, y0 = y0)
# denominator
lacp <- lacp - posterior(th = th0, y_obs = y_obs, y0 = y0)
lacp <- min(0, lacp)
# Note: The proposal is symmetrical and therefore does not appear in the value of acceptance / rejection!
lgu <- log(runif(1))  # lgu is negative
## if u < acp accept the move
if(lgu < lacp)
{
th0 <- delta
nacp = nacp + 1
}
if(isTRUE(all.equal(th0,c(NA,NA)))) cat("NA here! num iter = ", niter,"\n")
if(i>burnin & (i-burnin)%%thin==0)
{
th[(i-burnin)/thin,] = th0
}
if(i%%1000==0) cat("*** Iteration number ", i,"/", niter,"th=",tail(th,1) ,"\n")
}
cat("Acceptance rate =", nacp/niter, "\n")
return(th)
}
niter = 60000
burnin = 10000
thin = 10
# At the end the chain will contain
# (niter-burnin)/thin = 5000 observations
#th0 = map
th0 = c(0.5,-0.7)
th.post <- metro_hastings(niter = niter, burnin = burnin, thin = thin, th0 = th0, Sig = Sig, y0 = starting_point)
y_obs
t0 = -2
t_end = 2
N = 20
t_obs = seq(t0,t_end,length=N)
k1 = 0.219
k2 = 0.5287
k3 = -0.805
k4 = 0
y_true = k1*t_obs^3 + k2*t_obs^2 + k3*t_obs + k4
y_obs= k1*t_obs^3 + k2*t_obs^2 + k3*t_obs +k4 + rnorm(N,0,0.5)
windows()
plot(t_obs,y_obs)
lines(t_obs,y_true,col="red")
posterior <- function (th,y_obs,y0){
n = length(y_obs)
times = seq(-2,2, length = n)
y_mod = 0.219*times^3 + th[1]*times^2 + th[2]*times + 0
out = 0
#define the likelihood
for(i in 1:n)
{
out <- out + dnorm(y_obs[i],mean = y_mod[i], sd = 0.5,log=T)
}
#Multiply times the prior
out = out + dnorm(th[1], mean = 0, sd = 5, log = T) + dnorm(th[2], mean = 0, sd = 5, log = T)
return(out)
}
grid.k2 = seq(-2,2,length=50)
grid.k3 = seq(-2,2,length=50)
post_grid = matrix(nrow=50,ncol=50)
for(k in 1:50){
for(j in 1:50){
post_grid[k,j] = posterior(c(grid.k2[k],grid.k3[j]),y_obs,starting_point)
}
if(k%%10 == 0)
cat("k=",k, "\n")
}
persp(grid.k2, grid.k3, post_grid, theta = 30)
ottimo <- optim(par = c(mean(y_obs), log(sd(y_obs))),
fn = posterior, y_obs = y_obs,
y0 = y0,
hessian = T, control = list(fnscale=-1))
Sig <- - solve(ottimo$hessian)
Sig
metro_hastings <- function(niter, burnin, thin, th0, Sig,y0)
{
# define the vector that contains the output MCMC sample
th <- matrix(nrow= ceiling((niter-burnin)/thin), ncol = 2)
nacp = 0 # number of accepted moves
# Start from th0
for(i in 1:(niter))
{
## propose delta: the mean is given by the previous value
delta <- as.vector(rmvnorm(1, mean = th0, sig = Sig))
# First consider the log of accept/reject ratio
# numerator
lacp <- posterior(th = delta, y_obs = y_obs, y0 = y0)
# denominator
lacp <- lacp - posterior(th = th0, y_obs = y_obs, y0 = y0)
lacp <- min(0, lacp)
# Note: The proposal is symmetrical and therefore does not appear in the value of acceptance / rejection!
lgu <- log(runif(1))  # lgu is negative
## if u < acp accept the move
if(lgu < lacp)
{
th0 <- delta
nacp = nacp + 1
}
if(isTRUE(all.equal(th0,c(NA,NA)))) cat("NA here! num iter = ", niter,"\n")
if(i>burnin & (i-burnin)%%thin==0)
{
th[(i-burnin)/thin,] = th0
}
if(i%%1000==0) cat("*** Iteration number ", i,"/", niter,"th=",tail(th,1) ,"\n")
}
cat("Acceptance rate =", nacp/niter, "\n")
return(th)
}
niter = 60000
burnin = 10000
thin = 10
# At the end the chain will contain
# (niter-burnin)/thin = 5000 observations
#th0 = map
th0 = c(0.5,-0.7)
th.post <- metro_hastings(niter = niter, burnin = burnin, thin = thin, th0 = th0, Sig = Sig, y0 = starting_point)
posterior <- function (th,y_obs,y0){
n = length(y_obs)
times = seq(-2,2, length = n)
y_mod = 0.219*times^3 + th[1]*times^2 + th[2]*times + 0
out = 0
#define the likelihood
for(i in 1:n)
{
out <- out + dnorm(y_obs[i],mean = y_mod[i], sd = 0.5,log=T)
}
#Multiply times the prior
out = out + dnorm(th[1], mean = 0.5, sd = 1, log = T) + dnorm(th[2], mean = -0.5, sd = 5, log = T)
return(out)
}
posterior <- function (th,y_obs,y0){
n = length(y_obs)
times = seq(-2,2, length = n)
y_mod = 0.219*times^3 + th[1]*times^2 + th[2]*times + 0
out = 0
#define the likelihood
for(i in 1:n)
{
out <- out + dnorm(y_obs[i],mean = y_mod[i], sd = 0.5,log=T)
}
#Multiply times the prior
out = out + dnorm(th[1], mean = 0.5, sd = 1, log = T) + dnorm(th[2], mean = -0.5, sd = 5, log = T)
return(out)
}
metro_hastings <- function(niter, burnin, thin, th0, Sig,y0)
{
# define the vector that contains the output MCMC sample
th <- matrix(nrow= ceiling((niter-burnin)/thin), ncol = 2)
nacp = 0 # number of accepted moves
# Start from th0
for(i in 1:(niter))
{
## propose delta: the mean is given by the previous value
delta <- as.vector(rmvnorm(1, mean = th0, sig = Sig))
# First consider the log of accept/reject ratio
# numerator
lacp <- posterior(th = delta, y_obs = y_obs, y0 = y0)
# denominator
lacp <- lacp - posterior(th = th0, y_obs = y_obs, y0 = y0)
lacp <- min(0, lacp)
# Note: The proposal is symmetrical and therefore does not appear in the value of acceptance / rejection!
lgu <- log(runif(1))  # lgu is negative
## if u < acp accept the move
if(lgu < lacp)
{
th0 <- delta
nacp = nacp + 1
}
if(isTRUE(all.equal(th0,c(NA,NA)))) cat("NA here! num iter = ", niter,"\n")
if(i>burnin & (i-burnin)%%thin==0)
{
th[(i-burnin)/thin,] = th0
}
if(i%%1000==0) cat("*** Iteration number ", i,"/", niter,"th=",tail(th,1) ,"\n")
}
cat("Acceptance rate =", nacp/niter, "\n")
return(th)
}
th.post <- metro_hastings(niter = niter, burnin = burnin, thin = thin, th0 = th0, Sig = Sig, y0 = starting_point)
rm(list=ls(9))
rm(list=ls())
t0 = -2
t_end = 2
N = 20
t_obs = seq(t0,t_end,length=N)
#Set the true parameters
k1 = 0.219
k2 = 0.5287
k3 = -0.805
k4 = 0
y_true = k1*t_obs^3 + k2*t_obs^2 + k3*t_obs + k4
y_obs= k1*t_obs^3 + k2*t_obs^2 + k3*t_obs +k4 + rnorm(N,0,0.5)
plot(t_obs,y_obs)
lines(t_obs,y_true,col="red")
y_obs= k1*t_obs^3 + k2*t_obs^2 + k3*t_obs +k4 + rnorm(N,0,0.1)
plot(t_obs,y_obs)
lines(t_obs,y_true,col="red")
y_obs= k1*t_obs^3 + k2*t_obs^2 + k3*t_obs +k4 + rnorm(N,0,0.3)
plot(t_obs,y_obs)
lines(t_obs,y_true,col="red")
posterior <- function (th,y_obs,y0){
n = length(y_obs)
times = seq(-2,2, length = n)
y_mod = 0.219*times^3 + th[1]*times^2 + th[2]*times + 0
out = 0
#define the likelihood
for(i in 1:n)
{
out <- out + dnorm(y_obs[i],mean = y_mod[i], sd = 0.5,log=T)
}
#Multiply times the prior
out = out + dnorm(th[1], mean = 0.5, sd = 1, log = T) + dnorm(th[2], mean = -0.5, sd = 5, log = T)
return(out)
}
grid.k2 = seq(-2,2,length=50)
grid.k3 = seq(-2,2,length=50)
post_grid = matrix(nrow=50,ncol=50)
for(k in 1:50){
for(j in 1:50){
post_grid[k,j] = posterior(c(grid.k2[k],grid.k3[j]),y_obs,starting_point)
}
if(k%%10 == 0)
cat("k=",k, "\n")
}
persp(grid.k2, grid.k3, post_grid, theta = 30)
max(post_grid)
posterior <- function (th,y_obs,y0){
n = length(y_obs)
times = seq(-2,2, length = n)
y_mod = 0.219*times^3 + th[1]*times^2 + th[2]*times + 0
out = 0
#define the likelihood
for(i in 1:n)
{
out <- out + dnorm(y_obs[i],mean = y_mod[i], sd = 0.5,log=T)
}
#Multiply times the prior
out = out + dnorm(th[1], mean = 0.5, sd = 1, log = T) + dnorm(th[2], mean = -0.5, sd = 5, log = T)
return(out + 10.87)
}
grid.k2 = seq(-2,2,length=50)
grid.k3 = seq(-2,2,length=50)
post_grid = matrix(nrow=50,ncol=50)
for(k in 1:50){
for(j in 1:50){
post_grid[k,j] = posterior(c(grid.k2[k],grid.k3[j]),y_obs,starting_point)
}
if(k%%10 == 0)
cat("k=",k, "\n")
}
max(post_grid)
ottimo <- optim(par = c(mean(y_obs), log(sd(y_obs))),
fn = posterior, y_obs = y_obs,
y0 = y0,
hessian = T, control = list(fnscale=-1))
Sig <- - solve(ottimo$hessian)
Sig
metro_hastings <- function(niter, burnin, thin, th0, Sig,y0)
{
# define the vector that contains the output MCMC sample
th <- matrix(nrow= ceiling((niter-burnin)/thin), ncol = 2)
nacp = 0 # number of accepted moves
# Start from th0
for(i in 1:(niter))
{
## propose delta: the mean is given by the previous value
delta <- as.vector(rmvnorm(1, mean = th0, sig = Sig))
# First consider the log of accept/reject ratio
# numerator
lacp <- posterior(th = delta, y_obs = y_obs, y0 = y0)
# denominator
lacp <- lacp - posterior(th = th0, y_obs = y_obs, y0 = y0)
lacp <- min(0, lacp)
# Note: The proposal is symmetrical and therefore does not appear in the value of acceptance / rejection!
lgu <- log(runif(1))  # lgu is negative
## if u < acp accept the move
if(lgu < lacp)
{
th0 <- delta
nacp = nacp + 1
}
if(isTRUE(all.equal(th0,c(NA,NA)))) cat("NA here! num iter = ", niter,"\n")
if(i>burnin & (i-burnin)%%thin==0)
{
th[(i-burnin)/thin,] = th0
}
if(i%%1000==0) cat("*** Iteration number ", i,"/", niter,"th=",tail(th,1) ,"\n")
}
cat("Acceptance rate =", nacp/niter, "\n")
return(th)
}
niter = 60000
burnin = 10000
thin = 10
# At the end the chain will contain
# (niter-burnin)/thin = 5000 observations
#th0 = map
th0 = c(0.5,-0.7)
th.post <- metro_hastings(niter = niter, burnin = burnin, thin = thin, th0 = th0, Sig = Sig, y0 = starting_point)
niter = 60000
burnin = 10000
thin = 10
# At the end the chain will contain
# (niter-burnin)/thin = 5000 observations
#th0 = map
th0 = c(0.5,-0.7)
for(i in 1:(niter))
{
## propose delta: the mean is given by the previous value
delta <- as.vector(rmvnorm(1, mean = th0, sig = Sig))
# First consider the log of accept/reject ratio
# numerator
lacp <- posterior(th = delta, y_obs = y_obs, y0 = y0)
# denominator
lacp <- lacp - posterior(th = th0, y_obs = y_obs, y0 = y0)
lacp <- min(0, lacp)
# Note: The proposal is symmetrical and therefore does not appear in the value of acceptance / rejection!
lgu <- log(runif(1))  # lgu is negative
## if u < acp accept the move
if(lgu < lacp)
{
th0 <- delta
nacp = nacp + 1
}
cat("niter, th=",niter,th0,"\n")
line <- readline()
if(i>burnin & (i-burnin)%%thin==0)
{
th[(i-burnin)/thin,] = th0
}
if(i%%1000==0) cat("*** Iteration number ", i,"/", niter,"th=",tail(th,1) ,"\n")
}
th <- matrix(nrow= ceiling((niter-burnin)/thin), ncol = 2)
nacp = 0 # number of accepted moves
for(i in 1:(niter))
{
## propose delta: the mean is given by the previous value
delta <- as.vector(rmvnorm(1, mean = th0, sig = Sig))
# First consider the log of accept/reject ratio
# numerator
lacp <- posterior(th = delta, y_obs = y_obs, y0 = y0)
# denominator
lacp <- lacp - posterior(th = th0, y_obs = y_obs, y0 = y0)
lacp <- min(0, lacp)
# Note: The proposal is symmetrical and therefore does not appear in the value of acceptance / rejection!
lgu <- log(runif(1))  # lgu is negative
## if u < acp accept the move
if(lgu < lacp)
{
th0 <- delta
nacp = nacp + 1
}
cat("niter, th=",niter,th0,"\n")
line <- readline()
if(i>burnin & (i-burnin)%%thin==0)
{
th[(i-burnin)/thin,] = th0
}
if(i%%1000==0) cat("*** Iteration number ", i,"/", niter,"th=",tail(th,1) ,"\n")
}
