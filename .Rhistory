#Define a function for the evaluation of the system
circ_oscillator <- function(time,state,params){
k1 = params[1]
k2 = params[2]
k3 = params[3]
k4 = params[4]
k5 = params[5]
dx = k1/(36 + k2* state[2]) - k3
dy = k4*state[1] - k5
return(list(c(dx,dy)))
}
# Set the "true" parameters
k1 = 72
k2 = 1
k3 = 2
k4 = 1
k5 = 1
t_end = 30
y0 = c(7,-10)
t_obs=seq(0,t_end, by=0.5)
t_obs=seq(0,t_end, by=0.5)
#Set the "true" solutions evaluated in t_obs using ODE45
starting_point = c(7,-10)
y_true = ode(starting_point,t_obs,circ_oscillator,c(k1,k2,k3,k4,k5),method = "ode45")[,3]
N = length(y_true)
noise = rnorm(N-1,mean=0,sd=1)
y_obs = y_true
y_obs[2:N] = y_true[2:N] + noise
windows()
plot(t_obs,y_obs)
lines(t_obs,y_true,col="red")
## We assume k1,k2,k5,sigma(=0.5) known and assign a Gamma prior with parameters 1,1 to k3,k4
posterior <- function (th,y_obs,y0){
n = length(y_obs)
times = seq(0,60, by=0.5)
y_mod = ode(y0,times,circ_oscillator,c(72,1,th[1],th[2],1),method = "ode23")[,3]
out = 0
#define the likelihood
for(i in 1:n)
{
out <- out + dnorm(y_obs[i],mean = y_mod[i], sd = 0.5,log=T)
}
#Multiply times the prior
out = out + dmvnorm(th, mean = c(2,1), sigma = diag(0.1,2), log = T)
return(out)
}
for(k in 1:50){
for(j in 1:50){
post_grid[k,j] = posterior(c(grid.k3[k],grid.k4[j]),y_obs,starting_point)
}
if(k%%10 == 0)
cat("k=",k, "\n")
}
contour(grid.k3, grid.k4, post_grid, lwd = 1, labcex = 1.1, col = "blue", main = "Posterior density",
xlab = "k3", ylab = "k4")
for(i in seq(1,19,by=2)){
points(finalMatrix[,i],finalMatrix[,i+1])
}
dim(finalMatrix)
finalMatrix=read.csv(file="output_10_chains_par.csv")
dim(finalMatrix)
finalMatrix=finalMatrix[,2:20]
finalMatrix=read.csv(file="output_10_chains_par.csv")
finalMatrix=finalMatrix[,2:21]
contour(grid.k3, grid.k4, post_grid, lwd = 1, labcex = 1.1, col = "blue", main = "Posterior density",
xlab = "k3", ylab = "k4")
for(i in seq(1,19,by=2)){
points(finalMatrix[,i],finalMatrix[,i+1])
}
ccc=c(1,2,3)
A=NULL
rbind(A,ccc)
ottimo <- optim(par = c(mean(y_obs), log(sd(y_obs))),
fn = posterior, y_obs = y_obs,
y0 = y0,
hessian = T, control = list(fnscale=-1))
Sig
Sig <- - solve(ottimo$hessian)
Sig
gamma = 10
Sig = gamma * Sig
Sig
Sig = matrix(data = c(1.788331e-05, -0.0000462595, -4.625950e-05, 0.0001702542),nrow=2,ncol=2)
Sig
source("C:\\Users\\mario\\Desktop\\UNIVERSITA'\\Progetti\\bayesiana\\MH_toy_example.R")
rm(list=ls())
source("C:\\Users\\mario\\Desktop\\UNIVERSITA'\\Progetti\\bayesiana\simple_oscillator.R")
source("C:\\Users\\mario\\Desktop\\UNIVERSITA'\\Progetti\\bayesiana\\simple_oscillator.R")
source("C:\\Users\\mario\\Desktop\\UNIVERSITA'\\Progetti\\bayesiana\\simple_oscillator.R")
th3
k3
L = 11
alfa = numeric(L)
alfa = seq(0,1,length=L)
# A function defining the prior
prior <- function(th){
return(dgamma(th[1],16,8)*dgamma(th[2],8,8))
}
log_prior <- function(th){
out = log(dgamma(th[1],16,8)) + log(dgamma(th[2],8,8))
return(out)
}
likelihood <- function (th,y_obs,y0){
n = dim(y_obs)[1]
m = dim(y_obs)[2]
times = seq(0,30, by=0.5)
y_mod = ode(y0,times,circ_oscillator,c(72,1,th[1],th[2],1),method = "ode45")[,3]
out = 1
#define the likelihood
for(i in 1:n)
{
out <- out * dnorm(y_obs[i,],mean = y_mod[i,], sigma = 0.5 ,log=F)
}
return(out)
}
log_likelihood <- function (th,y_obs,y0){
n = length(y_obs)
times = seq(0,30, by=0.5)
y_mod = ode(y0,times,circ_oscillator,c(72,1,th[1],th[2],1),method = "ode45")[,3]
out = 0
#define the likelihood
for(i in 1:n)
{
out <- out + dnorm(y_obs[i],mean = y_mod[i], sd = 0.5,log=T)
}
return(out)
}
# A function defining the target density
target <- function(th,y_obs,y0,alfa,likelihood,prior){
return(likelihood(th,y_obs,y0)^alfa * prior(th) )
}
log_target <- function(th,y_obs,y0,alfa,likelihood,prior){
out = alfa*likelihood(th,y_obs,y0) + prior(th)
}
grid.k3 = seq(1.6,6,by=0,1)
grid.k3 = seq(1.6,6,by=01)
grid.k3 = seq(1.6,6,by=0.1)
grid.k3 = seq(0.6,5,by=0.1)
alfa = 0;
grid.k3 = seq(1.6,6,by=0.1)
grid.k4 = seq(0.6,5,by=0.1)
log_target <- function(th,y_obs,y0,alfa,log_likelihood,log_prior){
out = alfa*likelihood(th,y_obs,y0) + prior(th)
}
alfa = 0;
plot_grid = matrix(nrow=length(grid.k3), ncol=length(grid.k3))
for(i in (1:length(grid.k3))){
for(j in (1:length(grid.k3)))
plot_grid[i,j] = log_target(th = c(grid.k3(i),grid.k4(j)), y_obs = y_obs, y0=y0, alfa=alfa,log_likelihood = log_likelihood,log_prior = log_prior)
}
grid_k3 = seq(1.6,6,by=0.1)
grid_k4 = seq(0.6,5,by=0.1)
alfa = 0;
plot_grid = matrix(nrow=length(grid_k3), ncol=length(grid_k4))
for(i in (1:length(grid_k3))){
for(j in (1:length(grid_k4)))
plot_grid[i,j] = log_target(th = c(grid_k3(i),grid_k4(j)), y_obs = y_obs, y0=y0, alfa=alfa,log_likelihood = log_likelihood,log_prior = log_prior)
}
grid_k3 = seq(1.6,6,by=0.1)
grid_k4 = seq(0.6,5,by=0.1)
alfa = 0;
plot_grid = matrix(nrow=length(grid_k3), ncol=length(grid_k4))
for(i in (1:length(grid_k3))){
for(j in (1:length(grid_k4)))
plot_grid[i,j] = log_target(th = c(grid_k3[i],grid_k4[j])), y_obs = y_obs, y0=y0, alfa=alfa,log_likelihood = log_likelihood,log_prior = log_prior)
}
plot_grid = matrix(nrow=length(grid_k3), ncol=length(grid_k4))
for(i in (1:length(grid_k3))){
for(j in (1:length(grid_k4)))
plot_grid[i,j] = log_target(th = c(grid_k3[i],grid_k4[j]), y_obs = y_obs, y0=y0, alfa=alfa,log_likelihood = log_likelihood,log_prior = log_prior)
}
c(grid_k3[i],grid_k4[j])
plot_grid = matrix(nrow=length(grid_k3), ncol=length(grid_k4))
for(i in (1:length(grid_k3))){
for(j in (1:length(grid_k4)))
plot_grid[i,j] = log_target(th = c(grid_k3[i],grid_k4[j]), y_obs = y_obs, y0=y0, alfa=alfa,log_likelihood = log_likelihood,log_prior = log_prior)
}
log_target <- function(th,y_obs,y0,alfa,log_likelihood,log_prior){
out = alfa*log_likelihood(th,y_obs,y0) + log_prior(th)
}
plot_grid = matrix(nrow=length(grid_k3), ncol=length(grid_k4))
for(i in (1:length(grid_k3))){
for(j in (1:length(grid_k4)))
plot_grid[i,j] = log_target(th = c(grid_k3[i],grid_k4[j]), y_obs = y_obs, y0=y0, alfa=alfa,log_likelihood = log_likelihood,log_prior = log_prior)
}
1:n
log_likelihood <- function (th,y_obs,y0){
n = length(y_obs)
times = seq(0,30, by=0.5)
y_mod = ode(y0,times,circ_oscillator,c(72,1,th[1],th[2],1),method = "ode23")[,3]
out = 0
#define the likelihood
for(i in (1:n))
{
out <- out + dnorm(y_obs[i],mean = y_mod[i], sd = 0.5,log=T)
}
return(out)
}
plot_grid = matrix(nrow=length(grid_k3), ncol=length(grid_k4))
for(i in (1:length(grid_k3))){
for(j in (1:length(grid_k4)))
plot_grid[i,j] = log_target(th = c(grid_k3[i],grid_k4[j]), y_obs = y_obs, y0=y0, alfa=alfa,log_likelihood = log_likelihood,log_prior = log_prior)
}
n = length(y_obs)
times = seq(0,30, by=0.5)
y_mod = ode(y0,times,circ_oscillator,c(72,1,th[1],th[2],1),method = "ode23")[,3]
out = 0
#define the likelihood
for(i in (1:n))
{
out <- out + dnorm(y_obs[i],mean = y_mod[i], sd = 0.5,log=T)
}
th = c(grid_k3[i],grid_k4[j])
n = length(y_obs)
times = seq(0,30, by=0.5)
y_mod = ode(y0,times,circ_oscillator,c(72,1,th[1],th[2],1),method = "ode23")[,3]
out = 0
#define the likelihood
for(i in (1:n))
{
out <- out + dnorm(y_obs[i],mean = y_mod[i], sd = 0.5,log=T)
}
out
plot_grid = matrix(nrow=length(grid_k3), ncol=length(grid_k4))
for(i in (1:length(grid_k3))){
for(j in (1:length(grid_k4)))
plot_grid[i,j] = log_target(th=c(grid_k3[i],grid_k4[j]), y_obs = y_obs, y0=y0, alfa=alfa,log_likelihood = log_likelihood,log_prior = log_prior)
}
plot_grid = matrix(nrow=length(grid_k3), ncol=length(grid_k4))
for(i in (1:length(grid_k3))){
for(j in (1:length(grid_k4)))
plot_grid[i,j] = log_target(th=c(grid_k3[i],grid_k4[j]), y_obs = y_obs, y0=y0, alfa=alfa,log_likelihood = log_likelihood,log_prior = log_prior)
}
n = length(y_obs)
1:n
y0
alfa
log_target(th=c(grid_k3[i],grid_k4[j]), y_obs = y_obs, y0=y0, alfa=alfa,log_likelihood = log_likelihood,log_prior = log_prior)
log_likelihood <- function (th,y_obs,y0){
n = length(y_obs)
times = seq(0,30, by=0.5)
y_mod = ode(y0,times,circ_oscillator,c(72,1,th[1],th[2],1),method = "ode23")[,3]
out = 0
#define the likelihood
for(i in (1:n))
{
out <- out + dnorm(y_obs[i],mean = y_mod[i], sd = 0.5,log=T)
}
return(out)
}
log_likelihood <- function (th,y_obs,y0){
n = length(y_obs)
times = seq(0,30, by=0.5)
y_mod = ode(y0,times,circ_oscillator,c(72,1,th[1],th[2],1),method = "ode23")[,3]
out = 0
#define the likelihood
for(i in (1:n))
{
out <- out + dnorm(y_obs[i],mean = y_mod[i], sd = 0.5,log=T)
}
return(out)
}
log_target <- function(th,y_obs,y0,alfa,log_likelihood,log_prior){
out = alfa* log_likelihood(th,y_obs,y0) + log_prior(th)
}
th=c(1,1)
log_target(th,y_obs,y0,alfa,log_likelihood,log_prior)
log_target <- function(th,y_obs,y0,alfa,log_likelihood,log_prior){
out = alfa* log_likelihood(th,y_obs,y0) + log_prior(th)
return(out)
}
log_target(th,y_obs,y0,alfa,log_likelihood,log_prior)
plot_grid = matrix(nrow=length(grid_k3), ncol=length(grid_k4))
for(i in (1:length(grid_k3))){
for(j in (1:length(grid_k4)))
plot_grid[i,j] = log_target(th=c(grid_k3[i],grid_k4[j]), y_obs = y_obs, y0=y0, alfa=alfa,log_likelihood = log_likelihood,log_prior = log_prior)
}
persp(grid_k3, grid_k4, plot_grid, theta = 30)
x11()
persp(grid_k3, grid_k4, plot_grid, theta = 30)
alfa = 0.4
plot_grid = matrix(nrow=length(grid_k3), ncol=length(grid_k4))
for(i in (1:length(grid_k3))){
for(j in (1:length(grid_k4)))
plot_grid[i,j] = log_target(th=c(grid_k3[i],grid_k4[j]), y_obs = y_obs, y0=y0, alfa=alfa,log_likelihood = log_likelihood,log_prior = log_prior)
}
x11()
persp(grid_k3, grid_k4, plot_grid, theta = 30)
grid_k3 = seq(1.3,6,by=0.1)
grid_k4 = seq(0.3,5,by=0.1)
alfa = 0;
plot_grid = matrix(nrow=length(grid_k3), ncol=length(grid_k4))
for(i in (1:length(grid_k3))){
for(j in (1:length(grid_k4)))
plot_grid[i,j] = log_target(th=c(grid_k3[i],grid_k4[j]), y_obs = y_obs, y0=y0, alfa=alfa,log_likelihood = log_likelihood,log_prior = log_prior)
}
x11()
persp(grid_k3, grid_k4, plot_grid, theta = 30)
alfa = 0.4
plot_grid = matrix(nrow=length(grid_k3), ncol=length(grid_k4))
for(i in (1:length(grid_k3))){
for(j in (1:length(grid_k4)))
plot_grid[i,j] = log_target(th=c(grid_k3[i],grid_k4[j]), y_obs = y_obs, y0=y0, alfa=alfa,log_likelihood = log_likelihood,log_prior = log_prior)
}
x11()
persp(grid_k3, grid_k4, plot_grid, theta = 30)
alfa = 0.75
plot_grid = matrix(nrow=length(grid_k3), ncol=length(grid_k4))
for(i in (1:length(grid_k3))){
for(j in (1:length(grid_k4)))
plot_grid[i,j] = log_target(th=c(grid_k3[i],grid_k4[j]), y_obs = y_obs, y0=y0, alfa=alfa,log_likelihood = log_likelihood,log_prior = log_prior)
}
x11()
persp(grid_k3, grid_k4, plot_grid, theta = 30)
plot_grid = matrix(nrow=length(grid_k3), ncol=length(grid_k4))
for(i in (1:length(grid_k3))){
for(j in (1:length(grid_k4)))
plot_grid[i,j] = log_target(th=c(grid_k3[i],grid_k4[j]), y_obs = y_obs, y0=y0, alfa=alfa,log_likelihood = log_likelihood,log_prior = log_prior)
}
alfa = 1
plot_grid = matrix(nrow=length(grid_k3), ncol=length(grid_k4))
for(i in (1:length(grid_k3))){
for(j in (1:length(grid_k4)))
plot_grid[i,j] = log_target(th=c(grid_k3[i],grid_k4[j]), y_obs = y_obs, y0=y0, alfa=alfa,log_likelihood = log_likelihood,log_prior = log_prior)
}
x11()
persp(grid_k3, grid_k4, plot_grid, theta = 30)
plot_grid = matrix(nrow=length(grid_k3), ncol=length(grid_k4))
for(i in (1:length(grid_k3))){
for(j in (1:length(grid_k4)))
plot_grid[i,j] = log_target(th=c(grid_k3[i],grid_k4[j]), y_obs = y_obs, y0=y0, alfa=alfa,log_likelihood = log_likelihood,log_prior = log_prior)
}
x11()
plot_grid = matrix(nrow=length(grid_k3), ncol=length(grid_k4))
for(i in (1:length(grid_k3))){
for(j in (1:length(grid_k4)))
plot_grid[i,j] = log_target(th=c(grid_k3[i],grid_k4[j]), y_obs = y_obs, y0=y0, alfa=alfa,log_likelihood = log_likelihood,log_prior = log_prior)
}
x11()
persp(grid_k3, grid_k4, plot_grid, theta = 30)
persp(grid_k3, grid_k4, plot_grid, theta = 30)
target_density_sampler <- function(niter, burnin, th0, Sig,y0,alfa,log_target,log_likelihood, log_prior)
{
# define the vector that contains the output MCMC sample
th <- NULL
L = length(alfa)
nacp = 0 # number of accepted moves
# Start from th0
for(i in 1:(niter))
{
## propose delta: the mean is given by the previous value
## N.B: delta = c(th,alfa_i), we initially use a discrete uniform for alfa_i
delta <- c(as.vector(rmvnorm(1, mean = th0, sig = Sig)),sample(alfa,1))
# First consider the accept/reject ratio
# numerator
lacp <- log_target(th = delta[1:2], y_obs = y_obs, y0 = y0, alfa = delta[3], log_likelihood, log_prior)
# denominator
lacp <- lacp - log_target(th = th0[1:2], y_obs = y_obs, y0 = y0, alfa = th0[3], log_likelihood, log_prior)
#lacp <- min(0, lacp)
# Note: The proposal is symmetrical and therefore does not appear in the value of acceptance / rejection!
lgu <- log(runif(1))  # lgu is negative
## if u < acp accept the move
if(lgu < lacp)
{
th0 <- delta
nacp = nacp + 1
}
if(i>burnin & th0[3] == 1)
{
th=rbind(th,th0)
}
if(i%%1000==0) cat("*** Iteration number ", i,"/", niter,"th=",tail(th,1) ,"\n")
}
cat("Acceptance rate =", nacp/niter, "\n")
return(th)
}
Sig = matrix(data = c(1.788331e-05, -0.0000462595, -4.625950e-05, 0.0001702542),nrow=2,ncol=2)
niter=60000
burnin=10000
th0 = c(1.5,1)
alfa = seq(0,1,by=0.2)
th.post <- target_density_sampler(niter = niter, burnin = burnin, th0 = th0, Sig = Sig,y0 = y0,alfa = alfa,log_likelihood, log_prior)
dim(th.post)
log_target <- function(th,y_obs,y0,alfa,log_likelihood,log_prior){
out = alfa*log_likelihood(th,y_obs,y0) + log_prior(th)
return(out)
}
prior <- function(th){
return(dgamma(th[1],16,8)*dgamma(th[2],8,8))
}
log_prior <- function(th){
out = log(dgamma(th[1],16,8)) + log(dgamma(th[2],8,8))
return(out)
}
# A function defining the likelihood
likelihood <- function (th,y_obs,y0){
n = dim(y_obs)[1]
m = dim(y_obs)[2]
times = seq(0,30, by=0.5)
y_mod = ode(y0,times,circ_oscillator,c(72,1,th[1],th[2],1),method = "ode45")[,3]
out = 1
#define the likelihood
for(i in 1:n)
{
out <- out * dnorm(y_obs[i,],mean = y_mod[i,], sigma = 0.5 ,log=F)
}
return(out)
}
log_likelihood <- function (th,y_obs,y0){
n = length(y_obs)
times = seq(0,30, by=0.5)
y_mod = ode(y0,times,circ_oscillator,c(72,1,th[1],th[2],1),method = "ode23")[,3]
out = 0
#define the likelihood
for(i in (1:n))
{
out <- out + dnorm(y_obs[i],mean = y_mod[i], sd = 0.5,log=T)
}
return(out)
}
# A function defining the target density
target <- function(th,y_obs,y0,alfa,likelihood,prior){
return(likelihood(th,y_obs,y0)^alfa * prior(th) )
}
th.post <- target_density_sampler(niter = niter, burnin = burnin, th0 = th0, Sig = Sig,y0 = y0,alfa = alfa,log_likelihood, log_prior)
Q
delta = c(1,2,3)
log_target(th = delta[1:2], y_obs = y_obs, y0 = y0, alfa = delta[3], log_likelihood, log_prior)
th.post <- target_density_sampler(niter = niter, burnin = burnin, th0 = th0, Sig = Sig,y0 = y0,alfa = alfa,log_likelihood, log_prior)
log_target <- function(th,y_obs,y0,alfa){
out = alfa*log_likelihood(th,y_obs,y0) + log_prior(th)
return(out)
}
log_target <- function(th,y_obs,y0,alfa){
out = alfa*log_likelihood(th,y_obs,y0) + log_prior(th)
return(out)
}
target_density_sampler <- function(niter, burnin, th0, Sig,y0,alfa,log_target)
{
# define the vector that contains the output MCMC sample
th <- NULL
L = length(alfa)
th0=c(th0,alfa)
nacp = 0 # number of accepted moves
# Start from th0
for(i in 1:(niter))
{
## propose delta: the mean is given by the previous value
## N.B: delta = c(th,alfa_i), we initially use a discrete uniform for alfa_i
delta <- c(as.vector(rmvnorm(1, mean = th0, sig = Sig)),sample(alfa,1))
# First consider the accept/reject ratio
# numerator
lacp <- log_target(th = delta[1:2], y_obs = y_obs, y0 = y0, alfa = delta[3])
# denominator
lacp <- lacp - log_target(th = th0[1:2], y_obs = y_obs, y0 = y0, alfa = th0[3])
#lacp <- min(0, lacp)
# Note: The proposal is symmetrical and therefore does not appear in the value of acceptance / rejection!
lgu <- log(runif(1))  # lgu is negative
## if u < acp accept the move
if(lgu < lacp)
{
th0 <- delta
nacp = nacp + 1
}
if(i>burnin & th0[3] == 1)
{
th=rbind(th,th0)
}
if(i%%1000==0) cat("*** Iteration number ", i,"/", niter,"th=",tail(th,1) ,"\n")
}
cat("Acceptance rate =", nacp/niter, "\n")
return(th)
}
th.post <- target_density_sampler(niter = niter, burnin = burnin, th0 = th0, Sig = Sig,y0 = y0,alfa = alfa)
target_density_sampler <- function(niter, burnin, th0, Sig,y0,alfa,log_target)
{
# define the vector that contains the output MCMC sample
th <- NULL
L = length(alfa)
th0=c(th0,alfa)
nacp = 0 # number of accepted moves
# Start from th0
for(i in 1:(niter))
{
## propose delta: the mean is given by the previous value
## N.B: delta = c(th,alfa_i), we initially use a discrete uniform for alfa_i
delta <- c(as.vector(rmvnorm(1, mean = th0[1:2], sig = Sig)),sample(alfa,1))
# First consider the accept/reject ratio
# numerator
lacp <- log_target(th = delta[1:2], y_obs = y_obs, y0 = y0, alfa = delta[3])
# denominator
lacp <- lacp - log_target(th = th0[1:2], y_obs = y_obs, y0 = y0, alfa = th0[3])
#lacp <- min(0, lacp)
# Note: The proposal is symmetrical and therefore does not appear in the value of acceptance / rejection!
lgu <- log(runif(1))  # lgu is negative
## if u < acp accept the move
if(lgu < lacp)
{
th0 <- delta
nacp = nacp + 1
}
if(i>burnin & th0[3] == 1)
{
th=rbind(th,th0)
}
if(i%%1000==0) cat("*** Iteration number ", i,"/", niter,"th=",tail(th,1) ,"\n")
}
cat("Acceptance rate =", nacp/niter, "\n")
return(th)
}
th.post <- target_density_sampler(niter = niter, burnin = burnin, th0 = th0, Sig = Sig,y0 = y0,alfa = alfa)
th.post <- target_density_sampler(niter = niter, burnin = burnin, th0 = th0, Sig = Sig,y0 = y0,alfa = alfa,log_target)
