y_pred[i] = y_pred[i] + t(phi)%*%mu%*%posterior_models[k]
}
}
windows()
plot(t_true,y_pred)
K=10;
K=10;
# Set Uniform prior over the models
prior_models=rep(1/K,K)
# Bayesian Model-Averaged mean prediction
# E[y*|t*,y_obs,t_obs] = mu* = sum_over_all_models( phi^T * mu_k* posterior(M_k|y_obs,t_obs))
# phi^T = kx1 vector with the k basis of model M_k evaluated at t*
# mu_k = Sigma_k^(-1)* PHI^T *y_obs
#         PHI = Nxk matrix with basis responses at points t_obs
#         Sigma_k = I_k + PHI^T*PHI
# Posterior(M_k|y_obs,t_obs) = (p(y_obs|t_obs,M_k)*prior_models(k))/sum_k(p(y_obs|t_obs,M_k)*prior_models(k))
# p(y_obs|t_obs,M_k) = integrated likelihood
integrated_likelihood <- function(N,Sigma,PHI,y_obs)
{
out = gamma(1+N/2)/sqrt(pi^N*det(Sigma)) * (1 + 0.5* t(y_obs)%*%(diag(N)-PHI%*%solve(Sigma)%*%t(PHI))%*%y_obs)^(-1-N/2)
return(out)
}
# Setting the parameters for all the models, this implementation might be highly inefficient when
# the number of models is high
phi = matrix(nrow=N,ncol=1)
phi[,1] = t_obs;
PHI_1 = phi;
Sigma_1 = 1 + t(phi)%*%phi
mu_1 = solve(Sigma_1)%*%t(PHI_1)%*%y_obs
for(k in 2:K){
#for different basis functions, define the following line accordingly
phi = cbind(phi,t_obs^k)
#create PHI_k
assign(paste("PHI",k,sep="_"),phi)
#create Sigma_k
Sigma = diag(k) + t(phi)%*%phi
assign(paste("Sigma",k,sep="_"), Sigma)
#create mu_k, useful for the predictive
mu = solve(Sigma)%*%t(phi)%*%y_obs
assign(paste("mu",k,sep="_"),mu)
MU[k]=mu
}
#setting the normalizing constant for the posterior
posterior_denominator=0;
for(k in 1:K){
posterior_denominator = posterior_denominator + integrated_likelihood(N,get(paste("Sigma",k,sep="_")),get(paste("PHI",k,sep="_")),y_obs)
}
posterior_models=numeric(K);
for(k in 1:K){
posterior_models[k] = integrated_likelihood(N,get(paste("Sigma",k,sep="_")),get(paste("PHI",k,sep="_")),y_obs)/posterior_denominator
}
# Bayesian Model Averaged Mean Predictior
mu_ <- function(t_star,k,mu_k){
out = 0;
phi = numeric(k)
for(j in 1:k){
phi[j] = t_star^j
}
# for(j in 1:k){
out = out + t(phi)%*%mu_k*posterior_models[j]
#}
return(out)
}
#make predictions, evaluate mu_star
mu_star=0
L = length(t_true)
y_pred = numeric(L)
for(i in 1:L){
t_star=t_true[i]
for(k in 1:K){
phi = numeric(k)
for(j in 1:k){
phi[j] = t_star^j
}
mu = solve(get(paste("Sigma",k,sep="_")))%*%t(get(paste("PHI",k,sep="_")))%*%y_obs
y_pred[i] = y_pred[i] + t(phi)%*%mu%*%posterior_models[k]
}
}
windows()
plot(t_true,y_pred)
posterior_models
windows()
plot(posterior_models)
windows()
hist(posterior_models)
windows()
barplot(posterior_models)
install.packages("mvtnorm")
install.packages("deSolve")
install.packages("coda")
library(mvtnorm)
library(deSolve)
library(coda)
circ_oscillator <- function(time,state,params){
k1 = params[1]
k2 = params[2]
k3 = params[3]
k4 = params[4]
k5 = params[5]
dx = k1/(36 + k2* state[2]) - k3
dy = k4*state[1] - k5
return(list(c(dx,dy)))
}
# Set the "true" parameters
k1 = 72
k2 = 1
k3 = 2
k4 = 1
k5 = 1
t_end = 30
t_obs=seq(0,t_end, by=0.5)
#Set the "true" solutions evaluated in t_obs using ODE45
y0 = c(7,-10)
y_true = ode(y0,t_obs,circ_oscillator,c(k1,k2,k3,k4,k5),method = "ode45")[,2:3]
N = dim(y_true)[1]
noise = rmvnorm(N-1,mean=c(0,0),sigma=diag(0.5,2))
y_obs = y_true
y_obs[2:N,] = y_true[2:N,] + noise
y_obs = as.matrix(y_obs)
windows()
par(mfrow = c(1,2))
plot(t_obs,y_obs[,1])
lines(t_obs,y_true[,1],col="red")
plot(t_obs,y_obs[,2])
lines(t_obs,y_true[,2],col="red")
## We assume k1,k2,k5 known and assign a bivariate normal with mean (2,1) and sigma = diag(0.1,2)
posterior <- function (th,y_obs,y0){
n = dim(y_obs)[1]
m = dim(y_obs)[2]
times = seq(0,30, by=0.5)
y_mod = ode(y0,times,circ_oscillator,c(72,1,th[1],th[2],1),method = "ode45")[,2:3]
diff = max(abs(y_mod - y_obs))
#cat("diff" = diff, "\n")
out = 0
#define the likelihood
for(i in 1:n)
{
out <- out + dmvnorm(y_obs[i,],mean = y_mod[i,], sigma = diag(0.5,2),log=T)
}
#Multiply times the prior
out = out + dmvnorm(th, mean = c(2,1), sigma = diag(0.1,2), log = T)
return(out) + 132
}
#Plot the posterior on a grid
grid.k3 = seq(1.85,2.25,length=50)
grid.k4 = seq(0.85,1.25,length=50)
post_grid = matrix(nrow=50,ncol=50)
plot(y_obs[,2],col="red",type="l")
for(k in 1:50){
for(j in 1:50){
post_grid[k,j] = posterior(c(grid.k3[k],grid.k4[j]),y_obs,y0)
#th = c(grid.k3[k],grid.k4[j])
#lines(ode(y0,times,circ_oscillator,c(72,1,th[1],th[2],1),method = "ode45")[,3],col="blue")
}
if(k%%10 == 0)
cat("k=",k, "\n")
}
x11()
# Contour fun: Create a contour plot, or add contour lines to an existing plot
contour(grid.k3, grid.k4, post_grid, lwd = 3, labcex = 1.1, col = "blue", main = "Posterior density",
xlab = "k3", ylab = "k4")
x11()
persp(grid.k3, grid.k4, post_grid, theta = 30)
t_obs=seq(0,t_end, by=0.5)
#Set the "true" solutions evaluated in t_obs using ODE45
starting_point = c(7,-10)
y_true = ode(starting_point,t_obs,circ_oscillator,c(k1,k2,k3,k4,k5),method = "ode45")[,3]
N = length(y_true)
noise = rnorm(N-1,mean=0,sd=1)
y_obs = y_true
y_obs[2:N] = y_true[2:N] + noise
windows()
plot(t_obs,y_obs)
lines(t_obs,y_true,col="red")
## We assume k1,k2,k5,sigma(=0.5) known and assign a Gamma prior with parameters 1,1 to k3,k4
posterior <- function (th,y_obs,y0){
n = length(y_obs)
times = seq(0,60, by=0.5)
y_mod = ode(y0,times,circ_oscillator,c(72,1,th[1],th[2],1),method = "ode45")[,3]
out = 0
#define the likelihood
for(i in 1:n)
{
out <- out + dnorm(y_obs[i],mean = y_mod[i], sd = 0.5,log=T)
}
#Multiply times the prior
out = out + log(dgamma(th[1],1,1)) + log(dgamma(th[2],1,1))
return(out)
}
#Plot the posterior on a grid
grid.k3 = seq(0.01,4,length=50)
grid.k4 = seq(0.01,4,length=50)
post_grid = matrix(nrow=50,ncol=50)
for(k in 1:50){
for(j in 1:50){
post_grid[k,j] = posterior(c(grid.k3[k],grid.k4[j]),y_obs,starting_point)
}
if(k%%10 == 0)
cat("k=",k, "\n")
}
x11()
# Contour fun: Create a contour plot, or add contour lines to an existing plot
contour(grid.k3, grid.k4, post_grid, lwd = 3, labcex = 1.1, col = "blue", main = "Posterior density",
xlab = "k3", ylab = "k4")
x11()
persp(grid.k3, grid.k4, post_grid, theta = 30)
##########################
## Metropolis Hastings  ##
##########################
# Define the proposal as gaussian with suitable variance
ottimo <- optim(par = c(mean(y_obs), log(sd(y_obs))),
fn = posterior, y_obs = y_obs,
y0 = y0,
hessian = T, control = list(fnscale=-1))
Sig <- - solve(ottimo$hessian)
Sig
gamma = 1000
Sig = gamma * Sig
metro_hastings <- function(niter, burnin, thin, th0, Sig,y0)
{
# define the vector that contains the output MCMC sample
th <- matrix(nrow= ceiling((niter-burnin)/thin), ncol = 2)
nacp = 0 # number of accepted moves
# Start from th0
for(i in 1:(niter))
{
## propose delta: the mean is given by the previous value
delta <- as.vector(rmvnorm(1, mean = th0, sig = Sig))
# First consider the log of accept/reject ratio
# numerator
lacp <- posterior(th = delta, y_obs = y_obs, y0 = y0)
# denominator
lacp <- lacp - posterior(th = th0, y_obs = y_obs, y0 = y0)
if(is.nan(lacp))
lacp = 0
lacp <- min(0, lacp)
# Note: The proposal is symmetrical and therefore does not appear in the value of acceptance / rejection!
lgu <- log(runif(1))  # lgu is negative
## if u < acp accept the move
if(lgu < lacp)
{
th0 <- delta
nacp = nacp + 1
}
if(i>burnin & (i-burnin)%%thin==0)
{
th[(i-burnin)/thin,] = th0
}
if(i%%1000==0) cat("*** Iteration number ", i,"/", niter ,"\n")
}
cat("Acceptance rate =", nacp/niter, "\n")
return(th)
}
niter = 6000
burnin = 0
thin = 1
th0 = c(1.5,1)
th.post <- metro_hastings(niter = niter, burnin = burnin, thin = thin, th0 = th0, Sig = Sig, y0 = y0)
dim(th.post)
library(mvtnorm)
library(deSolve)
library(coda)
set.seed(09012017)
# Model: dx/dt = k1/(36 + k2* y) - k3
#        dy/dt = k4*x - k5
#Define a function for the evaluation of the system
circ_oscillator <- function(time,state,params){
k1 = params[1]
k2 = params[2]
k3 = params[3]
k4 = params[4]
k5 = params[5]
dx = k1/(36 + k2* state[2]) - k3
dy = k4*state[1] - k5
return(list(c(dx,dy)))
}
# Set the "true" parameters
k1 = 72
k2 = 1
k3 = 2
k4 = 1
k5 = 1
t_end = 30
t_obs=seq(0,t_end, by=0.5)
#Set the "true" solutions evaluated in t_obs using ODE45
y0 = c(7,-10)
y_true = ode(y0,t_obs,circ_oscillator,c(k1,k2,k3,k4,k5),method = "ode45")[,2:3]
N = dim(y_true)[1]
noise = rmvnorm(N-1,mean=c(0,0),sigma=diag(0.5,2))
y_obs = y_true
y_obs[2:N,] = y_true[2:N,] + noise
y_obs = as.matrix(y_obs)
windows()
par(mfrow = c(1,2))
plot(t_obs,y_obs[,1])
lines(t_obs,y_true[,1],col="red")
plot(t_obs,y_obs[,2])
lines(t_obs,y_true[,2],col="red")
t_obs=seq(0,t_end, by=0.5)
#Set the "true" solutions evaluated in t_obs using ODE45
starting_point = c(7,-10)
y_true = ode(starting_point,t_obs,circ_oscillator,c(k1,k2,k3,k4,k5),method = "ode45")[,3]
N = length(y_true)
noise = rnorm(N-1,mean=0,sd=1)
y_obs = y_true
y_obs[2:N] = y_true[2:N] + noise
windows()
plot(t_obs,y_obs)
lines(t_obs,y_true,col="red")
## We assume k1,k2,k5,sigma(=0.5) known and assign a Gamma prior with parameters 1,1 to k3,k4
posterior <- function (th,y_obs,y0){
n = length(y_obs)
times = seq(0,60, by=0.5)
y_mod = ode(y0,times,circ_oscillator,c(72,1,th[1],th[2],1),method = "ode45")[,3]
out = 0
#define the likelihood
for(i in 1:n)
{
out <- out + dnorm(y_obs[i],mean = y_mod[i], sd = 0.5,log=T)
}
#Multiply times the prior
out = out + dmvnorm(th, mean = c(2,1), sigma = diag(0.1,2), log = T)
return(out)
}
ottimo <- optim(par = c(mean(y_obs), log(sd(y_obs))),
fn = posterior, y_obs = y_obs,
y0 = y0,
hessian = T, control = list(fnscale=-1))
Sig <- - solve(ottimo$hessian)
Sig
gamma = 1000
Sig = gamma * Sig
metro_hastings <- function(niter, burnin, thin, th0, Sig,y0)
{
# define the vector that contains the output MCMC sample
th <- matrix(nrow= ceiling((niter-burnin)/thin), ncol = 2)
nacp = 0 # number of accepted moves
# Start from th0
for(i in 1:(niter))
{
## propose delta: the mean is given by the previous value
delta <- as.vector(rmvnorm(1, mean = th0, sig = Sig))
# First consider the log of accept/reject ratio
# numerator
lacp <- posterior(th = delta, y_obs = y_obs, y0 = y0)
# denominator
lacp <- lacp - posterior(th = th0, y_obs = y_obs, y0 = y0)
if(is.nan(lacp))
lacp = 0
lacp <- min(0, lacp)
# Note: The proposal is symmetrical and therefore does not appear in the value of acceptance / rejection!
lgu <- log(runif(1))  # lgu is negative
## if u < acp accept the move
if(lgu < lacp)
{
th0 <- delta
nacp = nacp + 1
}
if(i>burnin & (i-burnin)%%thin==0)
{
th[(i-burnin)/thin,] = th0
}
if(i%%1000==0) cat("*** Iteration number ", i,"/", niter ,"\n")
}
cat("Acceptance rate =", nacp/niter, "\n")
return(th)
}
niter = 16000
burnin = 10000
thin = 10
th0_vec = rmvnorm(10,mean=c(0,0),sigma=diag(c(20,20)))
library(foreach)
library(doParallel)
cores=detectCores()
cl <- makeCluster(cores[1]-1) #not to overload your computer
registerDoParallel(cl)
finalMatrix <- foreach(i=1:10, .packages = c("mvtnorm","deSolve"), .combine=cbind) %dopar% {
tempMatrix =  metro_hastings(niter = niter, burnin = burnin, thin = thin, th0 = th0_vec[i,], Sig = Sig, y0 = starting_point)
tempMatrix #Equivalent to finalMatrix = cbind(finalMatrix, tempMatrix)
}
stopCluster(cl)
finalMatrix<-NULL
for(i in 1:10){
tempMatrix =  metro_hastings(niter = niter, burnin = burnin, thin = thin, th0 = th0_vec[i,], Sig = Sig, y0 = starting_point)
finalMatrix = cbind(finalMatrix,tempMatrix)
}
posterior <- function (th,y_obs,y0){
n = length(y_obs)
times = seq(0,60, by=0.5)
y_mod = ode(y0,times,circ_oscillator,c(72,1,th[1],th[2],1),method = "ode23")[,3]
out = 0
#define the likelihood
for(i in 1:n)
{
out <- out + dnorm(y_obs[i],mean = y_mod[i], sd = 0.5,log=T)
}
#Multiply times the prior
out = out + dmvnorm(th, mean = c(2,1), sigma = diag(0.1,2), log = T)
return(out)
}
finalMatrix<-NULL
for(i in 1:10){
tempMatrix =  metro_hastings(niter = niter, burnin = burnin, thin = thin, th0 = th0_vec[i,], Sig = Sig, y0 = starting_point)
finalMatrix = cbind(finalMatrix,tempMatrix)
}
write.csv(finalMatrix, file="output_10_chains.csv")
range = c(min(finalMatrix),max(finalMatrix))
range
colmax = apply(finalMatrix,max,2)
colmin = apply(finalMatrix,min,2)
colmin = apply(finalMatrix,min,"2")
colmax = apply(finalMatrix,2,max)
colmin = apply(finalMatrix,2,min)
range_k3 = c(min(colmin[1],colmin[3],colmin[5],colmin[7],colmin[9],colmin[11],colmin[13],colmin[15],colmin[17],colmin[19]),
max(colmax[1],colmax[3],colmax[5],colmax[7],colmax[9],colmax[11],colmax[13],colmax[15],colmax[17],colmax[19]))
range_k4 = c(min(colmin[2],colmin[4],colmin[6],colmin[8],colmin[10],colmin[12],colmin[14],colmin[16],colmin[18],colmin[20]),
max(colmax[2],colmax[4],colmax[6],colmax[8],colmax[10],colmax[12],colmax[15],colmax[16],colmax[18],colmax[20]))
grid.k3 = seq(range_k3[1],range_k3[2],length=50)
grid.k4 = seq(range_k4[1],range_k4[2],length=50)
post_grid = matrix(nrow=50,ncol=50)
for(k in 1:50){
for(j in 1:50){
post_grid[k,j] = posterior(c(grid.k3[k],grid.k4[j]),y_obs,starting_point)
}
if(k%%10 == 0)
cat("k=",k, "\n")
}
contour(grid.k3, grid.k4, post_grid, lwd = 1, labcex = 1.1, col = "blue", main = "Posterior density",
xlab = "k3", ylab = "k4")
post_grid
grid.k3 = seq(1,range_k3[2],length=50)
grid.k4 = seq(1,range_k4[2],length=50)
post_grid = matrix(nrow=50,ncol=50)
for(k in 1:50){
for(j in 1:50){
post_grid[k,j] = posterior(c(grid.k3[k],grid.k4[j]),y_obs,starting_point)
}
if(k%%10 == 0)
cat("k=",k, "\n")
}
graphics.off()
contour(grid.k3, grid.k4, post_grid, lwd = 1, labcex = 1.1, col = "blue", main = "Posterior density",
xlab = "k3", ylab = "k4")
ottimo <- optim(par = c(mean(y_obs), log(sd(y_obs))),
fn = posterior, y_obs = y_obs,
y0 = y0,
hessian = T, control = list(fnscale=-1))
Sig <- - solve(ottimo$hessian)
Sig
gamma = 10
Sig = gamma * Sig
Sig
Sig = diag(c(0.5,0.5))
metro_hastings <- function(niter, burnin, thin, th0, Sig,y0)
{
# define the vector that contains the output MCMC sample
th <- matrix(nrow= ceiling((niter-burnin)/thin), ncol = 2)
nacp = 0 # number of accepted moves
# Start from th0
for(i in 1:(niter))
{
## propose delta: the mean is given by the previous value
delta <- as.vector(rmvnorm(1, mean = th0, sig = Sig))
# First consider the log of accept/reject ratio
# numerator
lacp <- posterior(th = delta, y_obs = y_obs, y0 = y0)
# denominator
lacp <- lacp - posterior(th = th0, y_obs = y_obs, y0 = y0)
lacp <- min(0, lacp)
# Note: The proposal is symmetrical and therefore does not appear in the value of acceptance / rejection!
lgu <- log(runif(1))  # lgu is negative
## if u < acp accept the move
if(lgu < lacp)
{
th0 <- delta
nacp = nacp + 1
}
if(i>burnin & (i-burnin)%%thin==0)
{
th[(i-burnin)/thin,] = th0
}
if(i%%1000==0) cat("*** Iteration number ", i,"/", niter ,"\n")
}
cat("Acceptance rate =", nacp/niter, "\n")
return(th)
}
niter = 16000
burnin = 10000
thin = 10
th0_vec = matrix(nrow = 10, ncol = 2)
?runif
th0_vec[,1] = runif(10,0.5,5)
th0_vec[,2] = runif(10,0.5,5)
library(foreach)
library(doParallel)
cores=detectCores()
cl <- makeCluster(cores[1]-1) #not to overload your computer
registerDoParallel(cl)
finalMatrix <- foreach(i=1:10, .packages = c("mvtnorm","deSolve"), .combine=cbind) %dopar% {
tempMatrix =  metro_hastings(niter = niter, burnin = burnin, thin = thin, th0 = th0_vec[i,], Sig = Sig, y0 = starting_point)
tempMatrix #Equivalent to finalMatrix = cbind(finalMatrix, tempMatrix)
}
#finalMatrix<-NULL
#for(i in 1:10){
#  tempMatrix =  metro_hastings(niter = niter, burnin = burnin, thin = thin, th0 = th0_vec[i,], Sig = Sig, y0 = starting_point)
#  finalMatrix = cbind(finalMatrix,tempMatrix)
#}
write.csv(finalMatrix, file="output_10_chains_par.csv")
stopCluster(cl)
write.csv(finalMatrix, file="output_10_chains_par.csv")
finalMatrix
dim(finalMatrix)
