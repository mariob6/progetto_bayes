finalMatrix=read.csv(file="output_10_chains_par.csv")
colmax = apply(finalMatrix,2,max)
colmin = apply(finalMatrix,2,min)
range_k3 = c(min(colmin[1],colmin[3],colmin[5],colmin[7],colmin[9],colmin[11],colmin[13],colmin[15],colmin[17],colmin[19]),
max(colmax[1],colmax[3],colmax[5],colmax[7],colmax[9],colmax[11],colmax[13],colmax[15],colmax[17],colmax[19]))
range_k4 = c(min(colmin[2],colmin[4],colmin[6],colmin[8],colmin[10],colmin[12],colmin[14],colmin[16],colmin[18],colmin[20]),
max(colmax[2],colmax[4],colmax[6],colmax[8],colmax[10],colmax[12],colmax[15],colmax[16],colmax[18],colmax[20]))
grid.k3 = seq(0.5,10,length=50)
grid.k4 = seq(0.5,10,length=50)
post_grid = matrix(nrow=50,ncol=50)
for(k in 1:50){
for(j in 1:50){
post_grid[k,j] = posterior(c(grid.k3[k],grid.k4[j]),y_obs,starting_point)
}
if(k%%10 == 0)
cat("k=",k, "\n")
}
library(mvtnorm)
library(deSolve)
library(coda)
circ_oscillator <- function(time,state,params){
k1 = params[1]
k2 = params[2]
k3 = params[3]
k4 = params[4]
k5 = params[5]
dx = k1/(36 + k2* state[2]) - k3
dy = k4*state[1] - k5
return(list(c(dx,dy)))
}
k1 = 72
k2 = 1
k3 = 2
k4 = 1
k5 = 1
t_end = 30
t_obs=seq(0,t_end, by=0.5)
y0 = c(7,-10)
y_true = ode(y0,t_obs,circ_oscillator,c(k1,k2,k3,k4,k5),method = "ode45")[,2:3]
N = dim(y_true)[1]
noise = rmvnorm(N-1,mean=c(0,0),sigma=diag(0.5,2))
y_obs = y_true
y_obs[2:N,] = y_true[2:N,] + noise
y_obs = as.matrix(y_obs)
t_obs=seq(0,t_end, by=0.5)
#Set the "true" solutions evaluated in t_obs using ODE45
starting_point = c(7,-10)
y_true = ode(starting_point,t_obs,circ_oscillator,c(k1,k2,k3,k4,k5),method = "ode45")[,3]
N = length(y_true)
noise = rnorm(N-1,mean=0,sd=1)
y_obs = y_true
y_obs[2:N] = y_true[2:N] + noise
posterior <- function (th,y_obs,y0){
n = length(y_obs)
times = seq(0,60, by=0.5)
y_mod = ode(y0,times,circ_oscillator,c(72,1,th[1],th[2],1),method = "ode23")[,3]
out = 0
#define the likelihood
for(i in 1:n)
{
out <- out + dnorm(y_obs[i],mean = y_mod[i], sd = 0.5,log=T)
}
#Multiply times the prior
out = out + dmvnorm(th, mean = c(2,1), sigma = diag(0.1,2), log = T)
return(out)
}
for(k in 1:50){
for(j in 1:50){
post_grid[k,j] = posterior(c(grid.k3[k],grid.k4[j]),y_obs,starting_point)
}
if(k%%10 == 0)
cat("k=",k, "\n")
}
grid.k3 = seq(0.5,10,length=50)
grid.k4 = seq(0.5,10,length=50)
post_grid = matrix(nrow=50,ncol=50)
for(k in 1:50){
for(j in 1:50){
post_grid[k,j] = posterior(c(grid.k3[k],grid.k4[j]),y_obs,starting_point)
}
if(k%%10 == 0)
cat("k=",k, "\n")
}
graphics.off()
grid.k3 = seq(0.5,10,length=50)
grid.k4 = seq(0.5,10,length=50)
post_grid = matrix(nrow=50,ncol=50)
for(k in 1:50){
for(j in 1:50){
post_grid[k,j] = posterior(c(grid.k3[k],grid.k4[j]),y_obs,starting_point)
}
if(k%%10 == 0)
cat("k=",k, "\n")
}
contour(grid.k3, grid.k4, post_grid, lwd = 1, labcex = 1.1, col = "blue", main = "Posterior density",
xlab = "k3", ylab = "k4")
for(i in seq(1,19,by=2){
points(finalMatrix[,i],finalMatrix[,i+1])
}
for(i in seq(1,19,by=2)){
points(finalMatrix[,i],finalMatrix[,i+1])
}
finalMatrix[,1]
finalMatrix=finalMatrix[,2:20]
contour(grid.k3, grid.k4, post_grid, lwd = 1, labcex = 1.1, col = "blue", main = "Posterior density",
xlab = "k3", ylab = "k4")
head(finalMatrix)
for(i in seq(1,19,by=2)){
points(finalMatrix[,i],finalMatrix[,i+1])
}
points(finalMatrix[,1],finalMatrix[,2])
points(finalMatrix[,3],finalMatrix[,4])
points(finalMatrix[,4],finalMatrix[,5])
max(finalMatrix)
min(finalMatrix)
grid.k3 = seq(-2,2,length=50)
grid.k4 = seq(-2,2,length=50)
post_grid = matrix(nrow=50,ncol=50)
for(k in 1:50){
for(j in 1:50){
post_grid[k,j] = posterior(c(grid.k3[k],grid.k4[j]),y_obs,starting_point)
}
if(k%%10 == 0)
cat("k=",k, "\n")
}
contour(grid.k3, grid.k4, post_grid, lwd = 1, labcex = 1.1, col = "blue", main = "Posterior density",
xlab = "k3", ylab = "k4")
for(i in seq(1,19,by=2)){
points(finalMatrix[,i],finalMatrix[,i+1])
}
for(i in seq(1,19,by=2)){
points(finalMatrix[:,i],finalMatrix[:,(i+1)])
}
for(i in seq(1,19,by=2)){
points(finalMatrix[,i],finalMatrix[,(i+1)])
}
seq(1,19,by=2)
i=1
points(finalMatrix[,i],finalMatrix[,(i+1)])
i=3
points(finalMatrix[,i],finalMatrix[,(i+1)])
i=4
points(finalMatrix[,i],finalMatrix[,(i+1)])
i=5
points(finalMatrix[,i],finalMatrix[,(i+1)])
i=7
points(finalMatrix[,i],finalMatrix[,(i+1)])
finalMatrix=read.csv(file="output_10_chains_par.csv")
dim(finalMatrix)
finalMatrix=finalMatrix[,2:21]
for(i in seq(1,17,by=2)){
points(finalMatrix[,i],finalMatrix[,(i+1)])
}
max(finalMatrix)
min(finalMatrix)
?dgamma
k3
posterior <- function (th,y_obs,y0){
n = length(y_obs)
times = seq(0,60, by=0.5)
y_mod = ode(y0,times,circ_oscillator,c(72,1,th[1],th[2],1),method = "ode23")[,3]
out = 0
#define the likelihood
for(i in 1:n)
{
out <- out + dnorm(y_obs[i],mean = y_mod[i], sd = 0.5,log=T)
}
#Multiply times the prior
out = out + log(dgamma(th[1],shape = 8, rate = 4)) + log(dgamma(th[2],shape = 8, rate = 4))
return(out)
}
grid.k3 = seq(1,4,length=50)
grid.k4 = seq(1,4,length=50)
post_grid = matrix(nrow=50,ncol=50)
for(k in 1:50){
for(j in 1:50){
post_grid[k,j] = posterior(c(grid.k3[k],grid.k4[j]),y_obs,starting_point)
}
if(k%%10 == 0)
cat("k=",k, "\n")
}
contour(grid.k3, grid.k4, post_grid, lwd = 3, labcex = 1.1, col = "blue", main = "Posterior density",
xlab = "k3", ylab = "k4")
k2
k3
k4
grid.k4 = seq(0.1,4,length=50)
grid.k3 = seq(0.1,4,length=50)
grid.k4 = seq(0.1,4,length=50)
post_grid = matrix(nrow=50,ncol=50)
for(k in 1:50){
for(j in 1:50){
post_grid[k,j] = posterior(c(grid.k3[k],grid.k4[j]),y_obs,starting_point)
}
if(k%%10 == 0)
cat("k=",k, "\n")
}
contour(grid.k3, grid.k4, post_grid, lwd = 3, labcex = 1.1, col = "blue", main = "Posterior density",
xlab = "k3", ylab = "k4")
posterior(c(2,1),y_obs,starting_point)
max(post_grid)
min(post_grid)
grid.k3
grid.k4
posterior(c(2.01,1.05),y_obs,starting_point)
grid.k3 = seq(0.1,4,by=0.1)
grid.k3 = seq(0.1,4,by=0.1)
grid.k4 = seq(0.1,4,by=0.1)
post_grid = matrix(nrow=length(grid.k3),ncol=length(grid.k4))
for(k in 1:50){
for(j in 1:50){
post_grid[k,j] = posterior(c(grid.k3[k],grid.k4[j]),y_obs,starting_point)
}
if(k%%10 == 0)
cat("k=",k, "\n")
}
for(k in 1:length(grid.k3)){
for(j in 1:length(grid.k4)){
post_grid[k,j] = posterior(c(grid.k3[k],grid.k4[j]),y_obs,starting_point)
}
if(k%%10 == 0)
cat("k=",k, "\n")
}
contour(grid.k3, grid.k4, post_grid, lwd = 3, labcex = 1.1, col = "blue", main = "Posterior density",
xlab = "k3", ylab = "k4")
grid.k3 = seq(0.1,4,by=0.1)
grid.k4 = seq(1.1,5,by=0.1)
post_grid = matrix(nrow=length(grid.k3),ncol=length(grid.k4))
for(k in 1:length(grid.k3)){
for(j in 1:length(grid.k4)){
post_grid[k,j] = posterior(c(grid.k3[k],grid.k4[j]),y_obs,starting_point)
}
if(k%%10 == 0)
cat("k=",k, "\n")
}
contour(grid.k3, grid.k4, post_grid, lwd = 3, labcex = 1.1, col = "blue", main = "Posterior density",
xlab = "k3", ylab = "k4")
k3
grid.k3 = seq(1.1,5,by=0.1)
grid.k4 = seq(0.1,5,by=0.1)
post_grid = matrix(nrow=length(grid.k3),ncol=length(grid.k4))
for(k in 1:length(grid.k3)){
for(j in 1:length(grid.k4)){
post_grid[k,j] = posterior(c(grid.k3[k],grid.k4[j]),y_obs,starting_point)
}
if(k%%10 == 0)
cat("k=",k, "\n")
}
contour(grid.k3, grid.k4, post_grid, lwd = 3, labcex = 1.1, col = "blue", main = "Posterior density",
xlab = "k3", ylab = "k4")
max(post_grid)
persp(grid.k3, grid.k4, post_grid, theta = 30)
contour(grid.k3, grid.k4, post_grid, lwd = 3, labcex = 1.1, col = "blue", main = "Posterior density",
xlab = "k3", ylab = "k4")
grid.k3 = seq(1.6,5.5,by=0.1)
grid.k4 = seq(0.1,5,by=0.1)
post_grid = matrix(nrow=length(grid.k3),ncol=length(grid.k4))
for(k in 1:length(grid.k3)){
for(j in 1:length(grid.k4)){
post_grid[k,j] = posterior(c(grid.k3[k],grid.k4[j]),y_obs,starting_point)
}
if(k%%10 == 0)
cat("k=",k, "\n")
}
contour(grid.k3, grid.k4, post_grid, lwd = 3, labcex = 1.1, col = "blue", main = "Posterior density",
xlab = "k3", ylab = "k4")
persp(grid.k3, grid.k4, post_grid, theta = 30)
contour(grid.k3, grid.k4, post_grid, lwd = 3, labcex = 1.1, col = "blue", main = "Posterior density",
xlab = "k3", ylab = "k4")
contour(grid.k3, grid.k4, exp(post_grid), lwd = 3, labcex = 1.1, col = "blue", main = "Posterior density",
xlab = "k3", ylab = "k4")
persp(grid.k3, grid.k4, exp(post_grid), theta = 30)
contour(grid.k3, grid.k4, post_grid, lwd = 3, labcex = 1.1, col = "blue", main = "Posterior density",
xlab = "k3", ylab = "k4")
plot(grid.k3,dgamma(grid.k3,shape = 8, rate = 4))
plot(grid.k4,dgamma(grid.k4,shape = 8, rate = 4))
plot(grid.k4,dgamma(grid.k4,shape = 16, rate = 8))
plot(grid.k4,dgamma(grid.k4,shape = 8, rate = 8))
posterior <- function (th,y_obs,y0){
n = length(y_obs)
times = seq(0,60, by=0.5)
y_mod = ode(y0,times,circ_oscillator,c(72,1,th[1],th[2],1),method = "ode23")[,3]
out = 0
#define the likelihood
for(i in 1:n)
{
out <- out + dnorm(y_obs[i],mean = y_mod[i], sd = 0.5,log=T)
}
#Multiply times the prior
out = out + log(dgamma(th[1],shape = 8, rate = 4)) + log(dgamma(th[2],shape = 8, rate = 4))
return(out)
}
grid.k3 = seq(1.6,5.5,by=0.1)
grid.k4 = seq(0.1,5,by=0.1)
post_grid = matrix(nrow=length(grid.k3),ncol=length(grid.k4))
for(k in 1:length(grid.k3)){
for(j in 1:length(grid.k4)){
post_grid[k,j] = posterior(c(grid.k3[k],grid.k4[j]),y_obs,starting_point)
}
if(k%%10 == 0)
cat("k=",k, "\n")
}
?optim
c(mean(y_obs), log(sd(y_obs))
)
ottimo <- optim(par = c(1,1),
fn = posterior, y_obs = y_obs,
y0 = y0,
hessian = T, control = list(fnscale=-1))
Sig <- - solve(ottimo$hessian)
Sig
ottimo <- optim(par = c(1,1),
fn = posterior, y_obs = y_obs,
y0 = y0,
hessian = T, control = list(fnscale=-1))
Sig <- - solve(ottimo$hessian)
Sig
gamma = 1
Sig = gamma * Sig
metro_hastings <- function(niter, burnin, thin, th0, Sig,y0)
{
# define the vector that contains the output MCMC sample
th <- matrix(nrow= ceiling((niter-burnin)/thin), ncol = 2)
nacp = 0 # number of accepted moves
# Start from th0
for(i in 1:(niter))
{
## propose delta: the mean is given by the previous value
delta <- as.vector(rmvnorm(1, mean = th0, sig = Sig))
# First consider the log of accept/reject ratio
# numerator
lacp <- posterior(th = delta, y_obs = y_obs, y0 = y0)
# denominator
lacp <- lacp - posterior(th = th0, y_obs = y_obs, y0 = y0)
lacp <- min(0, lacp)
# Note: The proposal is symmetrical and therefore does not appear in the value of acceptance / rejection!
lgu <- log(runif(1))  # lgu is negative
## if u < acp accept the move
if(lgu < lacp)
{
th0 <- delta
nacp = nacp + 1
}
if(i>burnin & (i-burnin)%%thin==0)
{
th[(i-burnin)/thin,] = th0
}
if(i%%1000==0) cat("*** Iteration number ", i,"/", niter ,"\n")
}
cat("Acceptance rate =", nacp/niter, "\n")
return(th)
}
niter = 16000
burnin = 10000
thin = 10
k3
