xlab = "k3", ylab = "k4")
grid.k3 = seq(1.6,5.5,by=0.1)
grid.k4 = seq(0.1,5,by=0.1)
post_grid = matrix(nrow=length(grid.k3),ncol=length(grid.k4))
for(k in 1:length(grid.k3)){
for(j in 1:length(grid.k4)){
post_grid[k,j] = posterior(c(grid.k3[k],grid.k4[j]),y_obs,starting_point)
}
if(k%%10 == 0)
cat("k=",k, "\n")
}
contour(grid.k3, grid.k4, post_grid, lwd = 3, labcex = 1.1, col = "blue", main = "Posterior density",
xlab = "k3", ylab = "k4")
persp(grid.k3, grid.k4, post_grid, theta = 30)
contour(grid.k3, grid.k4, post_grid, lwd = 3, labcex = 1.1, col = "blue", main = "Posterior density",
xlab = "k3", ylab = "k4")
contour(grid.k3, grid.k4, exp(post_grid), lwd = 3, labcex = 1.1, col = "blue", main = "Posterior density",
xlab = "k3", ylab = "k4")
persp(grid.k3, grid.k4, exp(post_grid), theta = 30)
contour(grid.k3, grid.k4, post_grid, lwd = 3, labcex = 1.1, col = "blue", main = "Posterior density",
xlab = "k3", ylab = "k4")
plot(grid.k3,dgamma(grid.k3,shape = 8, rate = 4))
plot(grid.k4,dgamma(grid.k4,shape = 8, rate = 4))
plot(grid.k4,dgamma(grid.k4,shape = 16, rate = 8))
plot(grid.k4,dgamma(grid.k4,shape = 8, rate = 8))
posterior <- function (th,y_obs,y0){
n = length(y_obs)
times = seq(0,60, by=0.5)
y_mod = ode(y0,times,circ_oscillator,c(72,1,th[1],th[2],1),method = "ode23")[,3]
out = 0
#define the likelihood
for(i in 1:n)
{
out <- out + dnorm(y_obs[i],mean = y_mod[i], sd = 0.5,log=T)
}
#Multiply times the prior
out = out + log(dgamma(th[1],shape = 8, rate = 4)) + log(dgamma(th[2],shape = 8, rate = 4))
return(out)
}
grid.k3 = seq(1.6,5.5,by=0.1)
grid.k4 = seq(0.1,5,by=0.1)
post_grid = matrix(nrow=length(grid.k3),ncol=length(grid.k4))
for(k in 1:length(grid.k3)){
for(j in 1:length(grid.k4)){
post_grid[k,j] = posterior(c(grid.k3[k],grid.k4[j]),y_obs,starting_point)
}
if(k%%10 == 0)
cat("k=",k, "\n")
}
?optim
c(mean(y_obs), log(sd(y_obs))
)
ottimo <- optim(par = c(1,1),
fn = posterior, y_obs = y_obs,
y0 = y0,
hessian = T, control = list(fnscale=-1))
Sig <- - solve(ottimo$hessian)
Sig
ottimo <- optim(par = c(1,1),
fn = posterior, y_obs = y_obs,
y0 = y0,
hessian = T, control = list(fnscale=-1))
Sig <- - solve(ottimo$hessian)
Sig
gamma = 1
Sig = gamma * Sig
metro_hastings <- function(niter, burnin, thin, th0, Sig,y0)
{
# define the vector that contains the output MCMC sample
th <- matrix(nrow= ceiling((niter-burnin)/thin), ncol = 2)
nacp = 0 # number of accepted moves
# Start from th0
for(i in 1:(niter))
{
## propose delta: the mean is given by the previous value
delta <- as.vector(rmvnorm(1, mean = th0, sig = Sig))
# First consider the log of accept/reject ratio
# numerator
lacp <- posterior(th = delta, y_obs = y_obs, y0 = y0)
# denominator
lacp <- lacp - posterior(th = th0, y_obs = y_obs, y0 = y0)
lacp <- min(0, lacp)
# Note: The proposal is symmetrical and therefore does not appear in the value of acceptance / rejection!
lgu <- log(runif(1))  # lgu is negative
## if u < acp accept the move
if(lgu < lacp)
{
th0 <- delta
nacp = nacp + 1
}
if(i>burnin & (i-burnin)%%thin==0)
{
th[(i-burnin)/thin,] = th0
}
if(i%%1000==0) cat("*** Iteration number ", i,"/", niter ,"\n")
}
cat("Acceptance rate =", nacp/niter, "\n")
return(th)
}
niter = 16000
burnin = 10000
thin = 10
k3
source("/home/mario/Scrivania/progetto_bayes/simple_oscillator.R")
L = 11
alfa = numeric(L)
alfa = seq(0,1,length=L)
# A function defining the prior
prior <- function(th){
return(dgamma(th[1],16,8)*dgamma(th[2],8,8))
}
log_prior <- function(th){
out = log(dgamma(th[1],16,8)) + log(dgamma(th[2],8,8))
return(out)
}
# A function defining the likelihood
likelihood <- function (th,y_obs,y0){
n = dim(y_obs)[1]
m = dim(y_obs)[2]
times = seq(0,30, by=0.5)
y_mod = ode(y0,times,circ_oscillator,c(72,1,th[1],th[2],1),method = "ode45")[,3]
out = 1
#define the likelihood
for(i in 1:n)
{
out <- out * dnorm(y_obs[i,],mean = y_mod[i,], sigma = 0.5 ,log=F)
}
return(out)
}
log_likelihood <- function (th,y_obs,y0){
n = length(y_obs)
times = seq(0,30, by=0.5)
y_mod = ode(y0,times,circ_oscillator,c(72,1,th[1],th[2],1),method = "ode23")[,3]
out = 0
#define the likelihood
for(i in (1:n))
{
out <- out + dnorm(y_obs[i],mean = y_mod[i], sd = 0.5,log=T)
}
return(out)
}
# A function defining the target density
target <- function(th,y_obs,y0,alfa,likelihood,prior){
return(likelihood(th,y_obs,y0)^alfa * prior(th) )
}
log_target <- function(th,y_obs,y0,alfa,log_likelihood,log_prior){
out = alfa*log_likelihood(th,y_obs,y0) + log_prior(th)
return(out)
}
alfa = seq(0,1,by=0.2)
target_density_sampler <- function(niter, burnin, th0, Sig,y0,alfa,log_target,log_likelihood, log_prior)
{
# define the vector that contains the output MCMC sample
th <- NULL
L = length(alfa)
nacp = 0 # number of accepted moves
# Start from th0
for(i in 1:(niter))
{
## propose delta: the mean is given by the previous value
## N.B: delta = c(th,alfa_i), we initially use a discrete uniform for alfa_i
delta <- c(as.vector(rmvnorm(1, mean = th0, sig = Sig)),sample(alfa,1))
# First consider the accept/reject ratio
# numerator
lacp <- log_target(th = delta[1:2], y_obs = y_obs, y0 = y0, alfa = delta[3], log_likelihood, log_prior)
# denominator
lacp <- lacp - log_target(th = th0[1:2], y_obs = y_obs, y0 = y0, alfa = th0[3], log_likelihood, log_prior)
#lacp <- min(0, lacp)
# Note: The proposal is symmetrical and therefore does not appear in the value of acceptance / rejection!
lgu <- log(runif(1))  # lgu is negative
## if u < acp accept the move
if(lgu < lacp)
{
th0 <- delta
nacp = nacp + 1
}
if(i>burnin & th0[3] == 1)
{
th=rbind(th,th0)
}
if(i%%1000==0) cat("*** Iteration number ", i,"/", niter,"th=",tail(th,1) ,"\n")
}
cat("Acceptance rate =", nacp/niter, "\n")
return(th)
}
Sig = matrix(data = c(1.788331e-05, -0.0000462595, -4.625950e-05, 0.0001702542),nrow=2,ncol=2)
niter=60000
burnin=10000
th0 = c(1.5,1)
alfa = seq(0,1,by=0.2)
th.post <- target_density_sampler(niter = niter, burnin = burnin, th0 = th0, Sig = Sig,y0 = y0,alfa = alfa,log_likelihood, log_prior)
dim(th.post)
th.post.mc <- mcmc(th.post, start = 0, end = niter, thin = 1)
source("/home/mario/Scrivania/progetto_bayes/simple_oscillator.R")
log_prior <- function(th){
out = log(dgamma(th[1],16,8)) + log(dgamma(th[2],8,8))
return(out)
}
log_likelihood <- function (th,y_obs,y0){
n = length(y_obs)
times = seq(0,30, by=0.5)
y_mod = ode(y0,times,circ_oscillator,c(72,1,th[1],th[2],1),method = "ode23")[,3]
out = 0
#define the likelihood
for(i in (1:n))
{
out <- out + dnorm(y_obs[i],mean = y_mod[i], sd = 0.5,log=T)
}
return(out)
}
log_target <- function(th,y_obs,y0,alfa){
out = alfa*log_likelihood(th,y_obs,y0) + log_prior(th)
return(out)
}
target_density_sampler <- function(niter, burnin, th0, Sig,y0,alfa,log_target)
{
# define the vector that contains the output MCMC sample
th <- NULL
L = length(alfa)
th0=c(th0,alfa)
nacp = 0 # number of accepted moves
# Start from th0
for(i in 1:(niter))
{
## propose delta: the mean is given by the previous value
## N.B: delta = c(th,alfa_i), we initially use a discrete uniform for alfa_i
delta <- c(as.vector(rmvnorm(1, mean = th0[1:2], sig = Sig)),sample(alfa,1))
# First consider the accept/reject ratio
# numerator
lacp <- log_target(th = delta[1:2], y_obs = y_obs, y0 = y0, alfa = delta[3])
# denominator
lacp <- lacp - log_target(th = th0[1:2], y_obs = y_obs, y0 = y0, alfa = th0[3])
#lacp <- min(0, lacp)
# Note: The proposal is symmetrical and therefore does not appear in the value of acceptance / rejection!
lgu <- log(runif(1))  # lgu is negative
## if u < acp accept the move
if(lgu < lacp)
{
th0 <- delta
nacp = nacp + 1
}
if(i>burnin & th0[3] == 1)
{
th=rbind(th,th0)
}
if(i%%1000==0) cat("*** Iteration number ", i,"/", niter,"th=",tail(th,1) ,"\n")
}
cat("Acceptance rate =", nacp/niter, "\n")
return(th)
}
Sig = matrix(data = c(1.788331e-05, -0.0000462595, -4.625950e-05, 0.0001702542),nrow=2,ncol=2)
niter=60000
burnin=10000
th0 = c(1.5,1)
alfa = seq(0,1,by=0.2)
th.post <- target_density_sampler(niter = niter, burnin = burnin, th0 = th0, Sig = Sig,y0 = y0,alfa = alfa,log_target)
th
dim(th.post)
plot_grid = matrix(nrow=length(grid_k3), ncol=length(grid_k4))
for(i in (1:length(grid_k3))){
for(j in (1:length(grid_k4)))
plot_grid[i,j] = log_target(th=c(grid_k3[i],grid_k4[j]), y_obs = y_obs, y0=y0, alfa=alfa,log_likelihood = log_likelihood,log_prior = log_prior)
}
x11()
persp(grid_k3, grid_k4, plot_grid, theta = 30)
############
target_density_sampler <- function(niter, burnin, th0, Sig,y0,alfa,log_target)
{
# define the vector that contains the output MCMC sample
th <- NULL
L = length(alfa)
th0=c(th0,alfa)
nacp = 0 # number of accepted moves
# Start from th0
for(i in 1:(niter))
{
## propose delta: the mean is given by the previous value
## N.B: delta = c(th,alfa_i), we initially use a discrete uniform for alfa_i
delta <- c(as.vector(rmvnorm(1, mean = th0[1:2], sig = Sig)),sample(alfa,1))
# First consider the accept/reject ratio
# numerator
lacp <- log_target(th = delta[1:2], y_obs = y_obs, y0 = y0, alfa = delta[3])
# denominator
lacp <- lacp - log_target(th = th0[1:2], y_obs = y_obs, y0 = y0, alfa = th0[3])
#lacp <- min(0, lacp)
# Note: The proposal is symmetrical and therefore does not appear in the value of acceptance / rejection!
lgu <- log(runif(1))  # lgu is negative
## if u < acp accept the move
if(lgu < lacp)
{
th0 <- delta
nacp = nacp + 1
}
if(i>burnin & th0[3] == 1)
{
th=rbind(th,th0)
cat("*** YEEEE \n")
}
if(i%%1000==0) cat("*** Iteration number ", i,"/", niter,"th=",tail(th,1) ,"\n")
}
cat("Acceptance rate =", nacp/niter, "\n")
return(th)
}
burnin=1000
th0 = c(1.5,1)
alfa = seq(0,1,by=0.2)
target_density_sampler <- function(niter, burnin, th0, Sig,y0,alfa,log_target)
{
# define the vector that contains the output MCMC sample
th <- NULL
L = length(alfa)
th0=c(th0,sample(alfa),1)
nacp = 0 # number of accepted moves
# Start from th0
for(i in 1:(niter))
{
## propose delta: the mean is given by the previous value
## N.B: delta = c(th,alfa_i), we initially use a discrete uniform for alfa_i
delta <- c(as.vector(rmvnorm(1, mean = th0[1:2], sig = Sig)),sample(alfa,1))
# First consider the accept/reject ratio
# numerator
lacp <- log_target(th = delta[1:2], y_obs = y_obs, y0 = y0, alfa = delta[3])
# denominator
lacp <- lacp - log_target(th = th0[1:2], y_obs = y_obs, y0 = y0, alfa = th0[3])
#lacp <- min(0, lacp)
# Note: The proposal is symmetrical and therefore does not appear in the value of acceptance / rejection!
lgu <- log(runif(1))  # lgu is negative
## if u < acp accept the move
if(lgu < lacp)
{
th0 <- delta
nacp = nacp + 1
}
if(i>burnin & th0[3] == 1)
{
th=rbind(th,th0)
cat("*** YEEEE \n")
}
if(i%%1000==0) cat("*** Iteration number ", i,"/", niter,"th=",tail(th,1) ,"\n")
}
cat("Acceptance rate =", nacp/niter, "\n")
return(th)
}
Sig = matrix(data = c(1.788331e-05, -0.0000462595, -4.625950e-05, 0.0001702542),nrow=2,ncol=2)
niter=60000
burnin=1000
th0 = c(1.5,1)
alfa = seq(0,1,by=0.2)
th.post <- target_density_sampler(niter = niter, burnin = burnin, th0 = th0, Sig = Sig,y0 = y0,alfa = alfa,log_target)
target_density_sampler <- function(niter, burnin, th0, Sig,y0,alfa,log_target)
{
# define the vector that contains the output MCMC sample
th <- NULL
L = length(alfa)
th0=c(th0,sample(alfa),1)
nacp = 0 # number of accepted moves
# Start from th0
for(i in 1:(niter))
{
## propose delta: the mean is given by the previous value
## N.B: delta = c(th,alfa_i), we initially use a discrete uniform for alfa_i
delta <- c(as.vector(rmvnorm(1, mean = th0[1:2], sig = Sig)),sample(alfa,1))
# First consider the accept/reject ratio
# numerator
lacp <- log_target(th = delta[1:2], y_obs = y_obs, y0 = y0, alfa = delta[3])
# denominator
lacp <- lacp - log_target(th = th0[1:2], y_obs = y_obs, y0 = y0, alfa = th0[3])
#lacp <- min(0, lacp)
# Note: The proposal is symmetrical and therefore does not appear in the value of acceptance / rejection!
lgu <- log(runif(1))  # lgu is negative
## if u < acp accept the move
if(lgu < lacp)
{
th0 <- delta
nacp = nacp + 1
}
if(i>burnin & th0[3] == 1)
{
th=rbind(th,th0)
cat("*** YEEEE \n")
}
if(i%%1000==0) cat("*** Iteration number ", i,"/", niter,"alfa= ",th0[3] ,"\n")
}
cat("Acceptance rate =", nacp/niter, "\n")
return(th)
}
th.post <- target_density_sampler(niter = niter, burnin = burnin, th0 = th0, Sig = Sig,y0 = y0,alfa = alfa,log_target)
alfa = seq(0,1,by=0.05)
target_density_sampler <- function(niter, burnin, th0, Sig,y0,alfa,log_target)
{
# define the vector that contains the output MCMC sample
th <- NULL
L = length(alfa)
th0=c(th0,1)
nacp = 0 # number of accepted moves
# Start from th0
for(i in 1:(niter))
{
## propose delta: the mean is given by the previous value
## N.B: delta = c(th,alfa_i), we initially use a discrete uniform for alfa_i
delta <- c(as.vector(rmvnorm(1, mean = th0[1:2], sig = Sig)),sample(alfa,1))
# First consider the accept/reject ratio
# numerator
lacp <- log_target(th = delta[1:2], y_obs = y_obs, y0 = y0, alfa = delta[3])
# denominator
lacp <- lacp - log_target(th = th0[1:2], y_obs = y_obs, y0 = y0, alfa = th0[3])
#lacp <- min(0, lacp)
# Note: The proposal is symmetrical and therefore does not appear in the value of acceptance / rejection!
lgu <- log(runif(1))  # lgu is negative
## if u < acp accept the move
if(lgu < lacp)
{
th0 <- delta
nacp = nacp + 1
}
if(i>burnin & th0[3] == 1)
{
th=rbind(th,th0)
cat("*** YEEEE \n")
}
if(i%%1000==0) cat("*** Iteration number ", i,"/", niter,"alfa= ",th0[3] ,"\n")
}
cat("Acceptance rate =", nacp/niter, "\n")
return(th)
}
burnin=1000
niter=60000
Sig = matrix(data = c(1.788331e-05, -0.0000462595, -4.625950e-05, 0.0001702542),nrow=2,ncol=2)
th0 = c(1.5,1)
alfa = seq(0,1,by=0.05)
th.post <- target_density_sampler(niter = niter, burnin = burnin, th0 = th0, Sig = Sig,y0 = y0,alfa = alfa,log_target)
target_density_sampler <- function(niter, burnin, th0, Sig,y0,alfa,log_target)
{
# define the vector that contains the output MCMC sample
th <- NULL
L = length(alfa)
th0=c(th0,1)
nacp = 0 # number of accepted moves
# Start from th0
for(i in 1:(niter))
{
## propose delta: the mean is given by the previous value
## N.B: delta = c(th,alfa_i), we initially use a discrete uniform for alfa_i
delta <- c(as.vector(rmvnorm(1, mean = th0[1:2], sig = Sig)),sample(alfa,1))
# First consider the accept/reject ratio
# numerator
lacp <- log_target(th = delta[1:2], y_obs = y_obs, y0 = y0, alfa = delta[3])
# denominator
lacp <- lacp - log_target(th = th0[1:2], y_obs = y_obs, y0 = y0, alfa = th0[3])
#lacp <- min(0, lacp)
# Note: The proposal is symmetrical and therefore does not appear in the value of acceptance / rejection!
lgu <- log(runif(1))  # lgu is negative
## if u < acp accept the move
if(lgu < lacp)
{
th0 <- delta
nacp = nacp + 1
}
cat("alfa="th0[3])
if(i>burnin & th0[3] == 1)
{
th=rbind(th,th0)
cat("*** YEEEE \n")
}
if(i%%1000==0) cat("*** Iteration number ", i,"/", niter,"alfa= ",th0[3] ,"\n")
}
cat("Acceptance rate =", nacp/niter, "\n")
return(th)
}
target_density_sampler <- function(niter, burnin, th0, Sig,y0,alfa,log_target)
{
# define the vector that contains the output MCMC sample
th <- NULL
L = length(alfa)
th0=c(th0,1)
nacp = 0 # number of accepted moves
# Start from th0
for(i in 1:(niter))
{
## propose delta: the mean is given by the previous value
## N.B: delta = c(th,alfa_i), we initially use a discrete uniform for alfa_i
delta <- c(as.vector(rmvnorm(1, mean = th0[1:2], sig = Sig)),sample(alfa,1))
# First consider the accept/reject ratio
# numerator
lacp <- log_target(th = delta[1:2], y_obs = y_obs, y0 = y0, alfa = delta[3])
# denominator
lacp <- lacp - log_target(th = th0[1:2], y_obs = y_obs, y0 = y0, alfa = th0[3])
#lacp <- min(0, lacp)
# Note: The proposal is symmetrical and therefore does not appear in the value of acceptance / rejection!
lgu <- log(runif(1))  # lgu is negative
## if u < acp accept the move
if(lgu < lacp)
{
th0 <- delta
nacp = nacp + 1
}
cat("alfa=" ,th0[3], "\n")
if(i>burnin & th0[3] == 1)
{
th=rbind(th,th0)
cat("*** YEEEE \n")
}
if(i%%1000==0) cat("*** Iteration number ", i,"/", niter,"alfa= ",th0[3] ,"\n")
}
cat("Acceptance rate =", nacp/niter, "\n")
return(th)
}
niter=10000
burnin=0
th0 = c(1.5,1)
alfa = seq(0,1,by=0.05)
th.post <- target_density_sampler(niter = niter, burnin = burnin, th0 = th0, Sig = Sig,y0 = y0,alfa = alfa,log_target)
